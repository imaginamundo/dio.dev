---
icon: ğŸš€
title: Criando um blog estÃ¡tico com Next.js e Markdown
summary: Um jeito de manter um blog pessoal sem se preocupar com banco de dados, hospedagem e performance.
createdAt:
  iso: '2020-08-30T20:18:54.073Z'
  formated: 30/08/2020
---

OlÃ¡, meu nome Ã© Diogo! Para estrear esse blog comeÃ§arei por ele mesmo, mostrando como ele foi feito e todas as partes. Mostrando desde o inÃ­cio do desenvolvimento atÃ© a subida para produÃ§Ã£o.

## PrÃ© requisitos

[Node](https://nodejs.org/) instalado no seu computador.

## Ferramentas

### Markdown

Uma linguagem de marcaÃ§Ã£o simples, que irÃ¡ gerar o conteÃºdo que utilizaremos nas postagens do blog. VocÃª pode ver como funcionam os usos bÃ¡sicos neste [Guia de Markdown](https://www.markdownguide.org/basic-syntax).

### Gray Matter

Para podemos transformar nossos arquivos Markdown em Objetos Javascript sem esforÃ§o.

### Remark

Com o Remark podemos transformar um conteÃºdo Markdown em HTML.

### Next.js

O [Next.js](https://nextjs.org/) Ã© um Framework de Javascript que facilita em muitas coisas no desenvolvimento de uma aplicaÃ§Ã£o para o [React.js](https://reactjs.org/). As principais funÃ§Ãµes que vamos usar dele sÃ£o:

#### Sistema de rotas separados por pastas

- Dentro da raiz do projeto podemos criar uma pasta chamada `src` e outra chamada `public`.

``` markdown
 ğŸ“¦projeto
 â”£ ğŸ“‚public
 â”ƒ â”— ğŸ–¼imagem.png
 â”£ ğŸ“‚src
 â”ƒ â”£ ğŸ“‚pages
 â”ƒ â”— â”— ğŸ“œindex.jsx
 â”ƒ â”— â”— ğŸ“œsobre.jsx
 â”ƒ â”— â”— ğŸ“œ[slug].jsx
```

**Pasta `public`**

Cada arquivo dentro da pasta public estarÃ¡ disponÃ­vel na raiz do domÃ­nio, no exemplo acima teremos uma rota para um arquivo `/imagem.png`.

Para saber mais consulte a [documentaÃ§Ã£o do Next.js para a pasta public](https://nextjs.org/docs/basic-features/static-file-serving).

**Pasta `src`**

Usada para separar dos arquivos que serÃ£o servidos estÃ¡ticamente dentro da pasta public. Dentro dele criaremos uma pasta chama `pages`, onde cada arquivo serÃ¡ uma rota. No modelo acima, temos os arquivos `index.jsx` e `slug.jsx`.

O arquivo **`index.jsx`** virarÃ¡ o diretÃ³rio raiz do projeto. Quando acessarmos a rota `meudominio.com`, ele irÃ¡ buscar nesse arquivo.

**`sobre.jsx`** irÃ¡ criar a rota `meudominio.com/sobre`.

O arquivo **`[slug].jsx`**, *slug* estÃ¡ entre colchetes, ele irÃ¡ criar uma rota variÃ¡vel, se entramos em `meudominio.com/qualquercoisa` ele irÃ¡ cair nessa rota. Esse serÃ¡ o arquivo principal para tratarmos cada postagem dentro do blog estÃ¡tico.

Para saber mais sobre a pasta `pages`, verifique a [documentaÃ§Ã£o de rotas de pÃ¡ginas do Next.js](https://nextjs.org/docs/basic-features/pages).

#### GeraÃ§Ã£o de pÃ¡ginas estÃ¡ticas

Essa funÃ§Ã£o do Next.js nos deixa criar pÃ¡ginas que podem consumir recursos externos, mas serem geradas na hora em que a aplicaÃ§Ã£o estÃ¡ sendo construida, e nÃ£o quando o usuÃ¡rio acessa a pÃ¡gina, nos dando mais performance e alguns outros benefÃ­cios.

#### FunÃ§Ãµes e componentes auxiliadores

Podemos usar vÃ¡rias das ferramentas do Next.js para facilitar nossa criaÃ§Ã£o de conteÃºdo. Alguns deles sÃ£o:
- **`<Link href="/">`:** Componente para auxiliar na mudanÃ§a de rotas, funciona tanto do lado do cliente (navegador), quanto do lado do servidor (Node);
- **`<Head>`:** Nos permite inserir meta tags por pÃ¡gina, tendo mais possibilidades para melhorar o *SEO*
- **`getStaticProps` e `getStaticPaths`:** FunÃ§Ãµes para buscar recursos estÃ¡ticos e criaÃ§Ã£o de rotas estÃ¡ticas, podendo utilizar tanto conteÃºdo estÃ¡tico (nosso caso com Markdown), ou de lugares externos, como Ã© bastante utilizado com `Headless CMS`.

### Remark

Remark Ã© um processador de Markdown que nos permite transforma-los em HTML e expor para o React.js imprimir o conteÃºdo na tela.

## Teoria

1. Node irÃ¡ ler cada arquivo Markdown com o Remark e criarÃ¡ um *Array* com cada objeto de Markdown guardando todas as informaÃ§Ãµes, isso funcionarÃ¡ como nosso *CMS* (*Content Management System*, ou gestor de conteÃºdo).

<figure>
  <img src="/node-lendo-markdowns.png" alt="Diagrama mostrando o node lendo markdowns" title="Diagrama mostrando o node lendo markdowns">
</figure>

2. O Next.js terÃ¡ acesso a esse *Array* e irÃ¡ tanto criar todas as rotas necessÃ¡rias, como tambÃ©m passar as informaÃ§Ãµes para cada rota.

## PrÃ¡tica

Primeiro vamos criar uma pasta para o nosso blog, recomendo usar o [Visual Studio Code](https://code.visualstudio.com/) para abrir essa pasta para ficar mais simples a organizaÃ§Ã£o, mas use o editor de cÃ³digo que achar o melhor.


### Instalando as dependencias que vamos usar
Abra o terminal (se estiver no Visual Studio Code, `Ctrl + J` abre o terminal) e digite o seguinte comando:

``` markdown
npm init
```

ApÃ³s vocÃª dar enter, ele vai perguntar algumas coisas, vocÃª pode preencher ou apertar enter que ele vai preencher com as respostas padrÃµes. Depois de responder todas as perguntas, ele criarÃ¡ um arquivo chamado package.json. Se vocÃª respondeu alguma coisa de um jeito que nÃ£o queria, pode editar esse arquivo, ou atÃ© mesmo apagar e rodar o comando novamente.

``` markdown
npm i next react react-dom gray-matter remark remark-html
```

Isso instalarÃ¡ todas as dependencias bÃ¡sicas que teremos no projeto.

### Adiciona comandos ao package.json

ApÃ³s a instalaÃ§Ã£o das dependÃªncias, vamos abrir nossos package.json e adicionar os comandos para podermos ver nosso cÃ³digo funcionando, vamos adicionar esse trecho dentro da chave scripts:
``` json
{
  "dev": "next dev",
  "build": "next build",
  "start": "next start"
}
```

Estamos adicionando os comandos do Next.js para rodar o projeto, isso inicializa o node com os comandos prÃ© definidos do Next.

O comando `dev`, roda em modo de desenvolvedor, recarregando automaticamente e com algumas outras coisas para agilizar no ambiente de desenvolvimento.

`build` gera uma versÃ£o do projeto para rodar em produÃ§Ã£o, focando em performance do cÃ³digo e carregamento das pÃ¡ginas.

`start` inicia a versÃ£o de produÃ§Ã£o gerada.

### Estrutura do Projeto

Faremos uma estrutura semelhante Ã  estrutura que mostrei explicando as rotas do Next.js. 

``` markdown
ğŸ“¦blog
 â”£ ğŸ“‚public
 â”£ ğŸ“‚src
 â”ƒ â”£ ğŸ“‚components
 â”ƒ â”£ ğŸ“‚pages
 â”ƒ â”£ ğŸ“‚posts
 â”ƒ â”— ğŸ“‚services
```

Criamos uma pasta de `components` para conseguir separar o cÃ³digo de uma forma mais organizada. TambÃ©m criamos uma pasta chamada `posts`, onde guardaremos nossos markdowns. A pÃ¡gina services Ã© onde guardaremos nossas buscas por markdowns com o Node.

### Criando um primeiro post

Dentro da pasta `posts`, vamos criar um arquivo chamado `ola-mundo.md`. Como Ã© sÃ³ um exemplo de post temos liberdade de fazer o que quisermos dentro dele, um exemplo de conteudo que podemos colocar dentro dele:

``` markdown
---
title: OlÃ¡ mundo!
author: Meu nome :D
date: '2020-08-30T16:53:22.171Z'
---

Seja bem vindo ao meu primeiro post!

## Espero que goste!

Tchau.
```

Nesse exemplo temos o cabeÃ§alho do markdown com os seguintes dado: `title`, `author` e `date`. O date usaremos para ordenar as postagens dentro da pÃ¡gina de listagem de postens.

O campo date Ã© uma ISOString, para criarmos uma Ã© bem simples, eu geralmente abro o console e digito o seguinte cÃ³digo:

``` javascript
(new Date()).toISOString()
```

Isso irÃ¡ nos retornar o dia e hora exato em que o cÃ³digo foi rodado.

### Criando nossa pÃ¡gina de lista de postagens

Para criar a nossa primeira rota, na pasta `pages`, criaremos o arquivo `index.jsx`.

Dentro dele podemos escrever:

``` javascript
export default function Page() {
  return <p>Minha rota!</p>;
}
```

Nesse exemplo, estamos apenas exportando uma funÃ§Ã£o que retorna um parÃ¡grafo escrito *Minha Rota*. VocÃª pode testar rodando o comando `npm run dev`, e com o seu browser, acessar a url <http://localhost:3000>.

#### Listando nossos markdowns

Para listar nossos markdowns vamos usar o Node, criaremos um arquivo chamado `api.js` (*Application Programming Interface*, ou Interface de ProgramaÃ§Ã£o de AplicaÃ§Ãµes), e essa serÃ¡ a nossa conexÃ£o entre o Next.js e os Markdowns, com o Node fazendo o processamento desses markdowns.

No cÃ³digo, nÃ³s primeiro vamos fazer um lista com todos os markdowns que temos (que por hora Ã© apenas 1).

``` javascript
/**
 * fs Ã© um mÃ³dulo nativo do Node,
 * nÃ£o precisamos instalar porque
 * ele vem com o node.
 * 
 * Esse modulo Ã© para ter acesso
 * aos arquivos do computador.
 */
import fs from 'fs';
/**
 * path Ã© outro mÃ³dulo nativo do
 * Node. Estamos buscando a funÃ§Ã£o
 * join dentro desse mÃ³dulo
 * 
 * join Ã© uma funÃ§Ã£o usada para unir
 * caminhos (paths) sem ter muito
 * trabalho, e ajudando para funcionar
 * em sistemas operacionais diferentes.
 */
import { join } from 'path';

/**
 * Primeiros definimos a rota onde estÃ£o
 * nossos posts.
 * 
 * process.cwd() Ã© uma funÃ§Ã£o do Node
 * que responde o caminho inicial atÃ© a
 * pasta onde o node estÃ¡ rodando, que
 * no nosso caso Ã© a pasta onde temos
 * nosso package.json.
 */
const postsDirectory = join(process.cwd(), 'src/posts');

function getMarkdownsFiles() {
  /**
   * Essa funÃ§Ã£o diz, leia o nome de
   * todos os arquivos dentro da pasta
   * que eu especifiquei na variÃ¡vel
   * postsDirectory e me retorne eles
   * em uma array.
   */
  return fs.readdirSync(postsDirectory);
}
/**
 * A funÃ§Ã£o getPostSlugs, irÃ¡ retornar:
 * > [ 'ola-mundo.md' ]
 */
```

Agora que jÃ¡ sabemos o nome dos nossos arquivos, podendo buscar seu conteÃºdo de uma forma mais simples.

#### Buscando informaÃ§Ãµes dentro do markdown

Nessa etapa, nÃ³s vamos dar um loop dentro do nosso *Array* de nomes de arquivos markdown com a funÃ§Ã£o `getAllPosts`, e dentro de cada um deles, buscar suas informaÃ§Ãµes com a funÃ§Ã£o `getPost`.

``` javascript
import fs from 'fs';
import { join } from 'path';
/**
 * Importamos o matter para conseguirmos
 * buscar os dados do Markdown como um
 * objeto.
 */
import matter from 'gray-matter';

const postsDirectory = join(process.cwd(), 'src/posts');

function getMarkdownsFiles() {
  return fs.readdirSync(postsDirectory);
}

/**
 * Criamos uma funÃ§Ã£o para buscar detalhes
 * de um post especÃ­fico, estamos exportando
 * essa funÃ§Ã£o pois ela serÃ¡ usada na pÃ¡gina
 * da postagem, onde nÃ£o precisaremos buscar 
 * o conteÃºdo.
 */
export function getPost(slugOrFilename) {
  // Remover o .md do fim do arquivo
  const slug = slugOrFilename.replace(/\.md$/, '');
  // Buscando pelo nome do arquivo markdown, com o .md
  const directory = join(postsDirectory, `${ slug }.md`);
  // Ler o conteÃºdo do arquivo markdown
  const fileContents = fs.readFileSync(directory, 'utf8');
  /**
   * Buscar o seu conteÃºdo
   * Com o matter, o cabeÃ§alho do Markdown
   * vem na chave data, e o conteÃºdo, dentro
   * do content.
   */
  const { data, content } = matter(fileContents);

  /**
   * Retornamos todo o conteÃºdo do markdown
   * junto com o slug.
   */
  return { content, slug, ...data };
}

/**
 * Criamos uma funÃ§Ã£o para buscar
 * todos os posts. Exportamos tambÃ©m
 * para consegir buscar de dentro da pÃ¡gina
 * de listagem de posts
 */
export function getAllPosts() {
  /**
   * Utilizamos a nossa funÃ§Ã£o para
   * retornar um array com os nomes
   * dos markdowns que temos.
   */
  const slugs = getMarkdownsFiles();
  
  /**
   * Criamos uma map (um loop em cada
   * Ã­ndice do array de slugs, que irÃ¡ nos
   * retornar outro array) que chama uma
   * funÃ§Ã£o para cada slug buscando detalhes
   * do post.
   */
  const posts = slugs
    .map(slug => getPost(slug));

  /**
   * Retornamos o post com
   * seus respectivos detalhes.
   */
  return posts;
}
```

Na funÃ§Ã£o `getAllPosts` utilizamos o mÃ©todo do *Javascript* [`.map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "DocumentaÃ§Ã£o do map() no MDN"), ela faz um loop dentro da *Array*, retornando o exato nÃºmero de itens da *Array* com o tratamento que escolhermos.

#### Filtrando o conteÃºdo das postagens

Com o cÃ³digo que temos atÃ© agora, recebemos todo o conteÃºdo do markdown assim:

``` javascript
{
  title: 'OlÃ¡ mundo!',
  author: 'Meu nome :D',
  date: '2020-08-30T16:53:22.171Z',
  content: 'Uma string com todo o conteÃºdo do markdown'
}
```

Vamos filtrar o conteÃºdo de cada postagem de uma forma dinÃ¢mica, para buscarmos somente o que precisamos, um exemplo, na pÃ¡gina de listagem de conteÃºdo nÃ£o precisamos do conteÃºdo da postagem, apenas do tÃ­tulo, data e slug.

``` javascript
import fs from 'fs';
import { join } from 'path';
import matter from 'gray-matter';

const postsDirectory = join(process.cwd(), 'src/posts');

function getMarkdownsFiles() {
  return fs.readdirSync(postsDirectory);
}

export function getPost(slugOrFilename, fields = []) {
  const slug = slugOrFilename.replace(/\.md$/, '');
  const directory = join(postsDirectory, `${ slug }.md`);
  const fileContents = fs.readFileSync(directory, 'utf8');

  
  const { data, content } = matter(fileContents);

  /**
   * Recebendo o campo fields, podemos criar nossa
   * postagem filtrada
   */
  const post = {};

  /**
   * Faremos um loop dentro dos campos necessÃ¡rios
   * para preencher nosso objeto post.
   */
  fields.forEach(field => {
    // Se houver o campo conteÃºdo, o adicionamos
    if (field === 'content') post[field] = content;
    // Se houver o campo slug, o adicionamos
    if (field === 'slug') post[field] = slug;
    /**
     * Se houver o campo dentro do cabeÃ§alho do
     * markdown, o adicionamos no post
     */
    if (data[field]) post[field] = data[field];
  })

  /**
   * Retornamos o nosso post filtrado
   */
  return post;
}

/**
 * Na funÃ§Ã£o getAllPosts inserimos um novo
 * parÃ¢metro para escolher os campos que
 * queremos. Ele Ã© um array com a chave dos
 * campos que queremos.
 */
export function getAllPosts(fields) {
  const slugs = getMarkdownsFiles();
  
  const posts = slugs
    /**
     * Passamos o Array de campos para dentro
     * da funÃ§Ã£o getPost.
     */
    
    .map(slug => getPost(slug, fields));

  return posts;
}
```

Alterando nosso cÃ³digo com o parÃ¢metro novo `fields` e utilizando o [`.filter()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter "DocumentaÃ§Ã£o do .filter()") podemos escolher os campos que queremos quando formos chamar a funÃ§Ã£o, podemos usar assim:

``` javascript
getAllPosts(['title', 'date', 'slug']);
```

IrÃ¡ nos retornar os posts com o conteÃºdo especificado na array, que no caso nÃ£o queremos a chave content, com o conteÃºdo do markdown.

``` javascript
[
  {
    title: 'OlÃ¡ mundo!',
    date: '2020-08-30T16:53:22.171Z',
    slug: 'ola-mundo'
  }
]
```

#### Ordernando as postagens

Para ordernar Ã© bem simples, jÃ¡ temos o campo `date` no cabeÃ§alho do nosso markdown, utilizaremos ele para ordernar nossos posts.

``` javascript
export function getAllPosts(fields = []) {
  const slugs = getMarkdownsFiles();
  
  const posts = slugs
    .map(slug => getPost(slug, fields))
    /**
     * Usaremos o .sort() para ordernar nossa
     * listagem de posts por data.
     */
    .sort((a, b) => new Date(b.date) - new Date(a.date));

  return posts;
}
```

Nossa funÃ§Ã£o getAllPosts recebeu sÃ³ mais uma linha com o mÃ©todo para arrays chamado [`.sort()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort "DocumentaÃ§Ã£o MDN do .sort()"). Esse Ã© um mÃ©todo um pouco dificil de comeÃ§ar a entender (foi para mim, pelo menos hahaha), mas depois fica mais tranquilo para usar.

#### Adicionado dados Ã  listagem de posts

Para isso voltaremos para nosso arquivo `src/pages/index.jsx` e chamaremos a funÃ§Ã£o que acabamos de terminar chamada `getAllPosts()`.

``` javascript
// Importamos nossa funÃ§Ã£o de buscar os posts
import { getAllPosts } from '../services/api.js';

export default function Page() {
  return <p>Minha rota!</p>;
}

/**
 * A funÃ§Ã£o getStaticProps Ã© do nextjs,
 * Ela busca recursos estÃ¡ticos para a sua pÃ¡gina,
 * sendo assim nÃ£o precisamos do servidor, ele gera
 * a pÃ¡gina com o conteÃºdo que lhe foi enviado. 
 */
export function getStaticProps() {
  // Chamamos ela com os campos que queremos
  const posts = getAllPosts([ 'title', 'date', 'slug' ]);

  // Retornamos ele como props para a pÃ¡gina.
  return {
    props: { posts }
  }
}
```

Utilizamos a funÃ§Ã£o [getStaticProps()](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation "DocumentaÃ§Ã£o da funÃ§Ã£o getInitialProps() do Next.js") do Next.js para trazer nossos recursos estÃ¡ticos (que nÃ£o mudam por um sistema externo).

#### Criando a listagem de posts com os dados estÃ¡ticos

Agora que buscamos nossos dados e colocamos na nossa rota, podemos utilizar ele no React.js do jeito que quisermos, fiz um modelo extremamente bÃ¡sico para mostrar como as postagem podem ser consumidas:

``` javascript
import Link from 'next/link';
import { getAllPosts } from '../services/api.js';

export default function Page({ posts }) {
  return (
    <>
      <h1>Meu blog!</h1>
      <p>Listagem de posts:</p>
      {
        posts.map(post => 
          <p>
            <Link href={ `/${ post.slug }` }>
              <a>{ post.title }</a>
            </Link>
          </p>
        )
      }
    </>
  );
}

export function getStaticProps() {
  const posts = getAllPosts([ 'title', 'date', 'slug' ]);

  return {
    props: { posts }
  }
}
```

Utilizamos o componente `<Link>` do NExt.js para conseguirmos fazer a transiÃ§Ã£o de pÃ¡ginas pelo lado do navegador (sem fazer uma outra requisiÃ§Ã£o para o servidor, apenas buscando o Javascript da outra pÃ¡gina e assim sendo mais rÃ¡pido para carregar).

Sua pÃ¡gina deve ficar semelhante a esta:

<figure>
  <img src="/listagem-de-posts-sem-estilo.png" title="PÃ¡gina de listagem de postagens sem estilo" alt="PÃ¡gina de listagem de postagens sem estilo">
</figure>

Podemos adicionar um pouco de CSS para ficar um pouco mais moderna, assim:

<figure>
  <img src="/listagem-de-posts-com-estilo.png" title="PÃ¡gina de listagem de postagens com estilo" alt="PÃ¡gina de listagem de postagens com estilo">
</figure>

O Next.js nos da algumas ferramentas para CSS, como [CSS Module, SAS Se  CSS in JS](https://nextjs.org/docs/basic-features/built-in-css-support "DocumentaÃ§Ã£o do Next.js para CSS"), recomendo a leitura para vocÃª conseguir fazer o seu conteÃºdo ficar com a cara que desejar.

Na pÃ¡gina atual temos um link que leva para uma pÃ¡gina de Erro 404, porque ainda nÃ£o criamos a rota de postagem. Para a rota de post criaremos o arquivo `src/pages/[slug].js`, e lÃ¡ teremos todo o conteÃºdo da nossa postagem.

#### Criando a pÃ¡gina de postagem Ãºnica

O arquivo `[slug].js` Ã© um arquivo que o Next.js irÃ¡ considerar como rota, onde conseguiremos ter o slug como variavel dentro da nossa rota. Se entramos em <http://localhost.com/ola-mundo> teremos o `slug` igual Ã  string `ola-mundo`.

Nessa parte do cÃ³digo iremos usar a funÃ§Ã£o que criamos `getPost()`, se lembram que ela requer dois parametros? O nome do markdown ou a slug, e os campos necessÃ¡rios. Ã‰ bem semelhante Ã  criaÃ§Ã£o da listagem de posts, mas buscando apenas um, ao invÃ©z de todos.

``` javascript
// Importamos nossa funÃ§Ã£o de buscar posts
import { getPost } from '../services/api.js';

export default function Page({ post }) {
  return (
    <>
      <h1>{ post.title }</h1>
      <p>{ post.author } Â· { post.date }</p>
      <p>
        { post.content }
      </p>
    </>
  );
}

/**
 * A funÃ§Ã£o getStaticProps nos traz os
 * parÃ¢metros que foram utilizados para
 * fazer a requisiÃ§Ã£o, com ele conseguimos
 * usar o nosso slug que foi trazido para
 * nÃ³s a partir da URL.
 */
export function getStaticProps({ params }) {
  /**
   * Utilizamos a funÃ§Ã£o de buscar postagem
   * passando o nome da rota (ola-mundo, nesse caso) 
   * e os campos que queremos.
   */
  const post = getPost(params.slug, [
    'title',
    'date',
    'author',
    'slug',
    'content'
  ]);

  return {
    props: { post }
  }
}
```

Para sevir os arquivos de forma estÃ¡tica com uma variÃ¡vel na URL, o Next.js requer que usemos uma outra funÃ§Ã£o dele, a [`getStaticPaths()`](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation "DocumentaÃ§Ã£o do getStaticPaths() do Next.js). Essa funÃ§Ã£o dirÃ¡ ao Next quais sÃ£o as rotas que ele tem que gerar, para nÃ£o precisarmos buscar essas informaÃ§Ãµes no servidor, gerando tudo quando rodarmos o comando `npm run build`.

#### Rotas estÃ¡ticas para as postagens do Blog

Usamos a funÃ§Ã£o `getStaticPaths()` e diremos ao Next.js todas as rodas possÃ­veis no blog, que no caso, Ã© uma rota para cada arquivo markdown dentro da pasta `src/posts`.

``` javascript
// Importamos a nossa funÃ§Ã£o getAllPosts()
import { getPost, getAllPosts } from '../services/api.js';

export default function Page({ post }) {
  return (
    <>
      <h1>{ post.title }</h1>
      <p>{ post.author } Â· { post.date }</p>
      <p>
        { post.content }
      </p>
    </>
  );
}

export function getStaticProps({ params }) {
  const post = getPost(params.slug, [
    'title',
    'date',
    'author',
    'slug',
    'content'
  ]);

  return {
    props: { post }
  }
}

// Usamos a funÃ§Ã£o do Next.js, getStaticPaths()
export function getStaticPaths() {
  // Buscamos todos os slugs e date de todos os posts
  const posts = getAllPosts(['slug', 'date']);

  return {
    /**
     * Retornamos para cada rota o parÃ¢metro slug,
     * para conseguirmos usÃ¡-lo na funÃ§Ã£o
     * getStaticProps acima.
     */
    paths: posts.map(post => ({
        params: {
          slug: post.slug
        }
    })),
    /**
     * A opÃ§Ã£o fallback: false fala para o Next.js
     * nÃ£o tentar executar essa rota se o arquivo
     * markdown para ela nÃ£o existir
     */
    fallback: false
  };
}
```

Nossa pÃ¡gina ficarÃ¡ parecida com essa sem nenhum CSS>

<figure>
  <img src="/post-com-markdown-sem-estilo.png" title="Post com markdown sem estilo" alt="Post com markdown sem estilo">
</figure>

Adicionando um pouco de estilo, a postagem ficarÃ¡ assim:

<figure>
  <img src="/post-com-markdown-com-estilo.png" title="Post com markdown com estilo" alt="Post com markdown com estilo">
</figure>

Reparem que temos dois problemas por hora: A data nÃ£o estÃ¡ formatada, e um problema levemente maior, **o markdown ainda nÃ£o virou HTML**. Agora estÃ¡ na hora de fazer o Remark brilhar e fazer essa transformaÃ§Ã£o markdown -> HTML.

#### Transformando Markdown para HTML com Remark

Para fazer essa transformaÃ§Ã£o criaremos um novo arquivo dentro da pasta `src/services`, chamado `markdown.js`.

Dentro desse arquivo terÃ¡ nossa funÃ§Ã£o responsÃ¡vel por transformar uma *String* em HTML para ser interpretado pelo React.js.

``` javascript
/**
 * Importamos os mÃ³dulos que instalamos
 * pelo NPM.
 */
// Processador para parsear markdown
import remark from 'remark';
// Serializador de markdown para string
import html from 'remark-html';

/**
 * Criamos nossa funÃ§Ã£o de transformar
 * string em HTML.
 * Ela Ã© uma funÃ§Ã£o assincrona, o que
 * ela sempre responderÃ¡ uma Promise e
 * nos darÃ¡ a possibilidade de esperar uma
 * Promise dentro dela terminar para 
 * continuar de uma forma simples.
 */
export async function toHTML(markdown) {
  // Processamos nosso conteÃºdo Markdown
  const result = await remark()
    .use(html)
    .process(markdown);

  /**
   * Retornamos ele de volta em formato
   * de String.
   */
  return result.toString();
}

/**
 * Exportamos o padrÃ£o como um objeto
 * com a funÃ§Ã£o para ficar mais bonito
 * utilizÃ¡-lo, utilizaremos ela assim:
 * markdown.toHTML(content)
 */
export default { toHTML };
```

Essa funÃ§Ã£o nos da tudo o que precisamos para renderizar o Markdown como react dentro do nosso conteÃºdo, agora vamos usÃ¡-la para transformar nossa nova *String* de HTML no React.js.

``` javascript
// Importamos nossa funÃ§Ã£o markdown
import markdown from '../services/markdown.js';
import { getAllPosts, getPost } from '../services/api.js';

export default function Page({ post }) {
  return (
    <div style={{
      margin: 'auto',
      maxWidth: '600px',
      fontFamily: 'sans-serif'
    }}>
      <h1>{ post.title }</h1>
      <p>{ post.author } Â· { post.date }</p>
      { /*
      Inserimos nosso na String HTML com
      dangerouslySetInnerHTML, para o React.js
      a interpretar como HTML.
      */ }
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </div>
  );
}

/**
 * Transformamos a funÃ§Ã£o getStaticProps
 * em assincrona
 */
export async function getStaticProps({ params }) {
  const post = getPost(params.slug, [
    'title',
    'date',
    'author',
    'slug',
    'content'
  ]);

  /**
   * Como a funÃ§Ã£o toHTML Ã© async, ela
   * retorna uma Promise, entÃ£o devemos 
   * aguardar ela ser finalizada com o await.
   */ 
  post.content = await markdown.toHTML(post.content);

  return {
    props: { post }
  }
}

export function getStaticPaths() {
  const posts = getAllPosts(['slug']);

  return {
    paths: posts.map(post => {
      return {
        params: {
          slug: post.slug
        }
      }
    }),
    fallback: false
  };
}
```

Agora quando vocÃª rodar o projeto, ele irÃ¡ ter a sua lista de postagens, ordenado por mais recente, e tambÃ©m conseguirÃ¡ rodar todas as pÃ¡ginas de forma estÃ¡tica, em breve postarei mais conteÃºdos sobre esse projeto, como deploy entre outras coisas.

Se vocÃª tem alguma dÃºvida, entre em contato comigo pelo twitter [@dioruto](https://twitter.com/dioruto).

Esse blog onde vocÃª estÃ¡ lendo esse artigo foi feito da mesma forma, mas com algumas coisas a mais para sanar as minhas necessidades, mais tratamentos de erros e performance SEO. Para ver como estÃ¡ acesse o [repositÃ³rio no GitHub](https://github.com/imaginamundo/dio.dev).

Pronto, agora vocÃª tem um blog com Markdown, ainda nÃ£o 100% otimizado, mas bem rÃ¡pido.

[Baixar o resultado inteiro desse artigo](/blog.rar).
